{"d":"\u003ch1\u003eApplies to\u003c/h1\u003e\n  \u003cul\u003e\n    \u003cli\u003eASP.NET 4.0\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003ch1\u003eWhat to Do\u003c/h1\u003e\n  \u003cp\u003eEncode user input displayed on pages.\u003c/p\u003e\n  \u003ch1\u003eWhy\u003c/h1\u003e\n  \u003cp\u003eEncode user input that is displayed on web pages to prevent Cross-Site Scripting attacks.\u003c/p\u003e\n  \u003ch1\u003eWhen\u003c/h1\u003e\n  \u003cp\u003eApplications should never echo untrusted or user modifiable data back to the user without appropriate encoding. \u003c/p\u003e\n  \u003ch1\u003eHow\u003c/h1\u003e\n  \u003cp\u003eIf you write output that includes user input or data from a shared database or a local file that you do not trust, encode it. Encoding the data ensures that it is treated as literal text and not as script. Use the following guidelines to encode user input:\u003c/p\u003e\n  \u003col\u003e\n    \u003cli\u003e\n      \u003cp\u003e\n        \u003cstrong\u003eDo not rely on HtmlEncode.\u003c/strong\u003e\u0026nbsp;ASP.NET\u0027s Server.HtmlEncode function is often used to protect against cross-site scripting attacks. However, this function only encodes \u0026lt;\u0026gt;\"\u0026 characters. This is not sufficient to protect against all possible attacks.\u003c/p\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cp\u003e\n        \u003cstrong\u003eEncode all special characters.\u003c/strong\u003e The safest solution is to encode all non-alphanumeric characters. Only this type of whitelist solution will catch all possible XSS attacks, regardless of context.\u0026nbsp; This\u0026nbsp;requires more overhead in terms of processing time and size of the resulting HTML, but it is the safest encoding mechanism for all HTML contexts:\u003c/p\u003e\n      \u003cpre\u003epublic static string HtmlEncode(string x)\u003cbr /\u003e{\u003cbr /\u003e   if (x == null)\u003cbr /\u003e   {\u003cbr /\u003e   \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;return x;\u003cbr /\u003e   }\u003cbr /\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;return Regex.Replace(x, \"^[a-zA-Z0-9]+$\",\u003cbr /\u003e    new MatchEvaluator(WebUtility.EncodeMatch));\u003cbr /\u003e}\u003c/pre\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cp /\u003e\n      \u003cstrong\u003eUse the Microsoft Anti-XSS Library.\u003c/strong\u003e If you are using the Anti-Cross Site Scripting Library, you can use the \u003cem\u003eMicrosoft.Security.Application.AntiXss.HtmlEncode\u003c/em\u003e method.\u0026nbsp;Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use \u003cem\u003eMicrosoft.Security.Application.AntiXss.UrlEncode\u003c/em\u003e to make them safe. \u003cp\u003e\u003cb\u003eNote: \u003c/b\u003eMake sure that you encode data at the last possible opportunity before the data is returned to the client.\u0026nbsp;If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems.\u003c/p\u003e\u003c/li\u003e\n  \u003c/ol\u003e\n  \u003chr /\u003e\n  \u003cp\u003eAdapted from Microsoft patterns \u0026 practices guidance. \u003c/p\u003e"}